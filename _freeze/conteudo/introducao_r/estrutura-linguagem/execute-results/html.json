{
  "hash": "cff30731e7e77e2ad3e90be20524e898",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Estrutura da linguagem\"\ndescription: \"Estrutura da linguagem R, incluindo operações básicas, tipos de objetos (vetores, data frames, matrizes, listas) e sintaxe principal.\"\ncategories: [\n          \"R\",\n          \"Programação\"\n        ]\nimage: \"images/estrutura-liguagem-r.jpg\"\nexecute:\n  echo: true\n  warning: false\n  include: true\n  message: false\n---\n\n\n\nR é um ambiente de software livre para computação estatística e gráfica que roda em uma variedade de plataformas UNIX, Windows e MacOS ([R Project](https://www.r-project.org/)). A instalação pode ser feita a partir do site oficial [CRAN](https://cran.r-project.org/), seguindo as instruções para cada plataforma. O [RStudio](https://rstudio.com/) é uma Interface de Desenvolvimento Integrado (IDE) dedicada ao ambiente R, embora existam outras opções como [Jupyter Notebook](https://jupyter.org/), [Jupyter Lab](https://jupyterlab.readthedocs.io/en/latest/), [Visual Studio Code](https://code.visualstudio.com/) e [Google Colab](https://colab.research.google.com/).\n\n## O R para cálculos aritméticos\n\nVamos iniciar nossa introdução ao R com seu uso mais simples, um ambiente para cálculos aritméticos. Como você verá, o R usa os operadores matemáticos de subtração (`-`), adição (`+`), multiplicação (`*`), divisão (`/`) e potenciação (`^`) do modo análogo a outros softwares.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n2 + 4\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 6\n```\n\n\n:::\n\n```{.r .cell-code}\n2 * 4\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 8\n```\n\n\n:::\n\n```{.r .cell-code}\n2 - 4\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] -2\n```\n\n\n:::\n\n```{.r .cell-code}\n2^4\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 16\n```\n\n\n:::\n:::\n\n\n\nAlém destes, temos operadores para extrairmos a parte inteira (`%%`) e o resto (`%/%`) de uma divisão.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n13%/%2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 6\n```\n\n\n:::\n\n```{.r .cell-code}\n13%%2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1\n```\n\n\n:::\n:::\n\n\n\nO uso de parênteses também permite o controle das operações matemáticas seguindo as prioridades conhecidas nestas operações. Por exemplo, a expressão:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n5 * (9 + 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 55\n```\n\n\n:::\n:::\n\n\n\né diferente de:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n5 * 9 + 2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 47\n```\n\n\n:::\n:::\n\n\n\nAssim como a expressão:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(3 + 4)^2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 49\n```\n\n\n:::\n:::\n\n\n\né diferente de:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n3 + 4^2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 19\n```\n\n\n:::\n:::\n\n\n\nExistem também funções aritméticas comuns como $log(x)$, $\\sqrt(x)$, $\\sin(x)$, o número $\\pi$, etc.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlog(100)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 4.60517\n```\n\n\n:::\n\n```{.r .cell-code}\nlog10(100)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2\n```\n\n\n:::\n\n```{.r .cell-code}\nlog(100, base = 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 6.643856\n```\n\n\n:::\n\n```{.r .cell-code}\nsqrt(36)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 6\n```\n\n\n:::\n\n```{.r .cell-code}\npi\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3.141593\n```\n\n\n:::\n\n```{.r .cell-code}\nsin(0.5 * pi)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1\n```\n\n\n:::\n:::\n\n\n\n## Atribuição de valores\n\nO R se estrutura por meio de **objetos**. Ao atribuir um valor a uma variável, esta se torna um **objeto** que fica disponível na memória. Para atribuir valor $2$ à variável `x` fazemos:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 2\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2\n```\n\n\n:::\n:::\n\n\n\nApós atribuir um valor à variável, esta fica disponível na memória da seção atual e pode ser utilizada em operações subsequentes.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ny <- x + 10\ny\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 12\n```\n\n\n:::\n:::\n\n\n\nAo atribuir outro valor à mesma variável, o valor inicial é substituído:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 5\ny <- x + 10\ny\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 15\n```\n\n\n:::\n:::\n\n\n\nO R diferencia caracteres minúsculos de MAIÚSCULOS. Portanto:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\na <- sqrt(49)\nA <- sqrt(81)\na\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 7\n```\n\n\n:::\n\n```{.r .cell-code}\nA\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 9\n```\n\n\n:::\n:::\n\n\n\n## Estruturas de dados\n\nOs objetos em R podem ser **vetores** (numéricos, alfanuméricos ou fatores), **matrizes** (numéricas ou alfanumétricas), **data frames** (estrutura bidimensional que pode combinar colunas de diferentes tipos como vetores numéricos, alfanuméricos ou fatores) ou **listas** (que pode combinar em sua estrutura, todos os objetos descritos acima). As **funções** em R são sequências de comandos que podem transformar objetos.\n\n### Vetores numéricos\n\nOs objetos podem guardar mais de um único valor. A função concatenar `c()` pode ser utilizada para criar um vetor com múltiplos valores. Dizemos que cada valor individual é uma *entrada*.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(4, 3.0, 5, 9, 10)\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  4  3  5  9 10\n```\n\n\n:::\n:::\n\n\n\nPodemos utilizar estes vetores em nossas operações.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ny <- x * 2\ny\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  8  6 10 18 20\n```\n\n\n:::\n:::\n\n\n\nNote que na operação acima, cada entrada foi multiplicada por $2$.\n\nPodemos ainda acessar e modificar entradas individuais. Por exemplo, o objeto `y` criado acima tem 5 elementos. O segundo elemento pode ser acessado com o comando:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ny[2]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 6\n```\n\n\n:::\n:::\n\n\n\nE alterado com o comando:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ny[2] <- 300\ny\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]   8 300  10  18  20\n```\n\n\n:::\n:::\n\n\n\nSe quisermos excluir o quarto elemento de `y` e gravar o resultado em um novo objeto `z` fazemos:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nz <- y[-4]\nz\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]   8 300  10  20\n```\n\n\n:::\n:::\n\n\n\n*Obs:* Veja que o quarto elemento, 18, foi excluído.\n\nPodemos obter a informação sobre o número de elementro do vetor. O vetor `y` tem tamanho igual a 5, enquanto o vetor `z` tem 4 elementos.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlength(y)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 5\n```\n\n\n:::\n\n```{.r .cell-code}\nlength(z)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 4\n```\n\n\n:::\n:::\n\n\n\n#### Sequências regulares e repetições {-}\n\nPodemos criar sequencias regulares.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n2:10\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  2  3  4  5  6  7  8  9 10\n```\n\n\n:::\n\n```{.r .cell-code}\nseq(2, 10, by = 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  2  4  6  8 10\n```\n\n\n:::\n\n```{.r .cell-code}\nseq(2, 10, length = 4)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  2.000000  4.666667  7.333333 10.000000\n```\n\n\n:::\n\n```{.r .cell-code}\nseq(2, 10, length = 10)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]  2.000000  2.888889  3.777778  4.666667  5.555556  6.444444  7.333333\n [8]  8.222222  9.111111 10.000000\n```\n\n\n:::\n:::\n\n\n\nE repetições de valores e vetores.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrep(4, times = 6)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 4 4 4 4 4 4\n```\n\n\n:::\n\n```{.r .cell-code}\nrep(c(2, 5), times = 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2 5 2 5 2 5\n```\n\n\n:::\n\n```{.r .cell-code}\nrep(c(2, 5), each = 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2 2 2 5 5 5\n```\n\n\n:::\n:::\n\n\n\nOs resultados destas sequências podem ser guardadas em um objeto para utilização subsequente.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\na <- seq(2, 10, by = 2)\na\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  2  4  6  8 10\n```\n\n\n:::\n\n```{.r .cell-code}\nb <- seq(10, 2, by = -2)\nb\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 10  8  6  4  2\n```\n\n\n:::\n\n```{.r .cell-code}\nc <- a + b\nc\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 12 12 12 12 12\n```\n\n\n:::\n:::\n\n\n\n### Vetores alfanuméricos\n\nSão vetores em que cada entrada é um caracter alfanumerico.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nespecie = c(\"Deuterodon iguape\", \n            \"Characidium japuhybense\", \n            \"Trichomycterus zonatus\")\nespecie\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Deuterodon iguape\"       \"Characidium japuhybense\"\n[3] \"Trichomycterus zonatus\" \n```\n\n\n:::\n:::\n\n\n\nExiste uma variedade de funções para manipulação de vetores alfanuméricos.\n\nA função `sort()` por exemplo, aplicada a um vetor *numérico* é utilizada para ordená-lo de forma crescente:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\na = c(5,2,15,12)\na\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  5  2 15 12\n```\n\n\n:::\n\n```{.r .cell-code}\nsort(a)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  2  5 12 15\n```\n\n\n:::\n:::\n\n\n\nou decrescente:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsort(a, decreasing = T)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 15 12  5  2\n```\n\n\n:::\n:::\n\n\n\nSe aplicada a um vetor alfanumerico esta função ordena o vetor em ordem alfabética:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsort(especie, decreasing = FALSE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Characidium japuhybense\" \"Deuterodon iguape\"      \n[3] \"Trichomycterus zonatus\" \n```\n\n\n:::\n\n```{.r .cell-code}\nsort(especie, decreasing = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Trichomycterus zonatus\"  \"Deuterodon iguape\"      \n[3] \"Characidium japuhybense\"\n```\n\n\n:::\n:::\n\n\n\n### Unindo vetores: comando `paste`\n\nSuponha que desejamos unir dois vetores alfanuméricos\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx1 <- c(\"Experimento\")\nx2 <- c(\"A\", \"B\", \"C\")\nx3 <- paste(x1, x2, sep = \"_\")\n```\n:::\n\n\n\nO mesmo resultado pode ser obtido de forma mais concisa com o comando:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx4 <- paste(\"Experimento\", LETTERS[1:3], sep = \"_\")\nx4\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Experimento_A\" \"Experimento_B\" \"Experimento_C\"\n```\n\n\n:::\n:::\n\n\n\n### Fatores\n\nFatores são como vetores alfanuméricos, porém com um atributo adicional. Fatores são compostos por diferentes níveis. Por exemplo, podemos criar o objeto `dosagem` com o comando:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndosagem <- c(\"Alta\", \"Alta\", \"Alta\", \n            \"Media\", \"Media\", \"Media\", \n            \"Baixa\", \"Baixa\", \"Baixa\")\ndosagem\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Alta\"  \"Alta\"  \"Alta\"  \"Media\" \"Media\" \"Media\" \"Baixa\" \"Baixa\" \"Baixa\"\n```\n\n\n:::\n:::\n\n\n\nNo exemplo acima, o R não reconhece as palavras `Alta`, `Media` e `Baixa` como diferentes níveis. Para isto devemos transformá-lo em um fator:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndosagem <- factor(dosagem)\ndosagem\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] Alta  Alta  Alta  Media Media Media Baixa Baixa Baixa\nLevels: Alta Baixa Media\n```\n\n\n:::\n:::\n\n\n\nO objeto dosagem agora é um fator com 3 níveis.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlevels(dosagem)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Alta\"  \"Baixa\" \"Media\"\n```\n\n\n:::\n\n```{.r .cell-code}\nnlevels(dosagem)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3\n```\n\n\n:::\n\n```{.r .cell-code}\nlevels(dosagem)[2]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Baixa\"\n```\n\n\n:::\n:::\n\n\n\nNote entretanto que os níveis foram reconhecidos em ordem alfabética. Se quisermos ordenar este níveis de outro modo fazemos:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndosagem <- factor(dosagem, ordered = TRUE, \n                 levels = c(\"Baixa\", \"Media\", \"Alta\"))\ndosagem\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] Alta  Alta  Alta  Media Media Media Baixa Baixa Baixa\nLevels: Baixa < Media < Alta\n```\n\n\n:::\n:::\n\n\n\nComo veremos a frente, esta operação facilita a visualização gráfica de fatores ordenados.\n\n### Matrizes\n\nMatrizes são objetos compostos por linhas e colunas. No R, uma matriz pode ser construída inicialmente criando um vetor numérico:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\na <- c(21,26,5,18,17,28,20,15,13,14,27,22)\na\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] 21 26  5 18 17 28 20 15 13 14 27 22\n```\n\n\n:::\n:::\n\n\n\nEm seguida o vetor pode ser organizado em uma matriz definindo-se o número de linhas e de colunas que sejam compatíveis com o tamanho do vetor. No exemplo acima o vetor tem comprimento 12 e pode ser organizado em uma matriz de $3$ linhas e $4$ colunas:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- matrix(a, nrow = 3, ncol = 4)\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3] [,4]\n[1,]   21   18   20   14\n[2,]   26   17   15   27\n[3,]    5   28   13   22\n```\n\n\n:::\n:::\n\n\n\nNote que os elementos foram adicionados um por vez de **coluna em coluna**. Se quisermos preencher a matriz **por linhas** adicionamos ao comando, o argumento `byrow = TRUE`.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- matrix(a, nrow = 3, ncol = 4, byrow = TRUE)\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3] [,4]\n[1,]   21   26    5   18\n[2,]   17   28   20   15\n[3,]   13   14   27   22\n```\n\n\n:::\n:::\n\n\n\nOs elementos de uma matriz podem ser acessados indicando sua posição na linha e na coluna. Por exemplo, o elemento da $2^a$ linha e $3^a$ coluna de `x` pode ser acessados pelo comando:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx[2, 3]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 20\n```\n\n\n:::\n:::\n\n\n\nDe modo análogo, a $2^a$ linha pode ser acessada por:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx[2, ]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 17 28 20 15\n```\n\n\n:::\n:::\n\n\n\nE a $4^a$ coluna por:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx[, 4]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 18 15 22\n```\n\n\n:::\n:::\n\n\n\nValores individuais em matrizes podem ser alterados de forma similar ao que é realizasdo em vetores. Por exemplo, para alterar o elemento da $2^a$ linha e $3^a$ coluna de `x` por $1000$ fazemos:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx[2, 3] <- 1000\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3] [,4]\n[1,]   21   26    5   18\n[2,]   17   28 1000   15\n[3,]   13   14   27   22\n```\n\n\n:::\n:::\n\n\n\nTambém podemos excluir linhas e colunas de uma matriz.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx[-2,]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3] [,4]\n[1,]   21   26    5   18\n[2,]   13   14   27   22\n```\n\n\n:::\n\n```{.r .cell-code}\nx[,-3]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3]\n[1,]   21   26   18\n[2,]   17   28   15\n[3,]   13   14   22\n```\n\n\n:::\n:::\n\n\n\nNote que, acima, não salvamos os resultados da exclusão das linhas e colunas de `x` em nenhum objeto, de modo que `x` continua inalterado.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3] [,4]\n[1,]   21   26    5   18\n[2,]   17   28 1000   15\n[3,]   13   14   27   22\n```\n\n\n:::\n:::\n\n\n\nPodemos criar matrizes unindo vetores de tamanho iguais em linhas ou colunas.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 3:12\ny <- 12:3\nrbind(x, y)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10]\nx    3    4    5    6    7    8    9   10   11    12\ny   12   11   10    9    8    7    6    5    4     3\n```\n\n\n:::\n\n```{.r .cell-code}\ncbind(x, y)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n       x  y\n [1,]  3 12\n [2,]  4 11\n [3,]  5 10\n [4,]  6  9\n [5,]  7  8\n [6,]  8  7\n [7,]  9  6\n [8,] 10  5\n [9,] 11  4\n[10,] 12  3\n```\n\n\n:::\n:::\n\n\n\nEventualmente, se desejarmos atribuir nomes às linhas e às colunas de uma matriz, podemos fazê-lo por meio das funções `rownames()` e `colnames()` respectivamente:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx_mat <- matrix(1:12, nrow = 3, ncol = 4)\nx_mat\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3] [,4]\n[1,]    1    4    7   10\n[2,]    2    5    8   11\n[3,]    3    6    9   12\n```\n\n\n:::\n\n```{.r .cell-code}\nrownames(x_mat) <- paste(\"Linha\", 1:3, sep = \"\")\nx_mat\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n       [,1] [,2] [,3] [,4]\nLinha1    1    4    7   10\nLinha2    2    5    8   11\nLinha3    3    6    9   12\n```\n\n\n:::\n\n```{.r .cell-code}\ncolnames(x_mat) <- paste(\"Coluna\", 1:4, sep = \"\")\nx_mat\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n       Coluna1 Coluna2 Coluna3 Coluna4\nLinha1       1       4       7      10\nLinha2       2       5       8      11\nLinha3       3       6       9      12\n```\n\n\n:::\n:::\n\n\n\n### Data frames\n\nAssim como Matrizes, **Data frames** são estruturas que permitem organizar dados em formato de linhas e colunas. No R entanto, as Matrizes não podem guardar objetos de diferentes características. Por exemplo, uma matriz pode ser composta inteiramente numérica:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmatrix(1:12, nrow = 4, ncol = 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3]\n[1,]    1    5    9\n[2,]    2    6   10\n[3,]    3    7   11\n[4,]    4    8   12\n```\n\n\n:::\n:::\n\n\n\nOu alfanumérica:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmatrix(letters[1:12], nrow = 4, ncol = 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3]\n[1,] \"a\"  \"e\"  \"i\" \n[2,] \"b\"  \"f\"  \"j\" \n[3,] \"c\"  \"g\"  \"k\" \n[4,] \"d\"  \"h\"  \"l\" \n```\n\n\n:::\n:::\n\n\n\nPorém, se tentarmos unir um vetor numérico a um vetor alfanumérico, toda a matriz será convertida no formato alfanumérico.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nz <- LETTERS[3:12]\nz\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] \"C\" \"D\" \"E\" \"F\" \"G\" \"H\" \"I\" \"J\" \"K\" \"L\"\n```\n\n\n:::\n\n```{.r .cell-code}\ncbind(x, z)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n      x    z  \n [1,] \"3\"  \"C\"\n [2,] \"4\"  \"D\"\n [3,] \"5\"  \"E\"\n [4,] \"6\"  \"F\"\n [5,] \"7\"  \"G\"\n [6,] \"8\"  \"H\"\n [7,] \"9\"  \"I\"\n [8,] \"10\" \"J\"\n [9,] \"11\" \"K\"\n[10,] \"12\" \"L\"\n```\n\n\n:::\n:::\n\n\n\nPara unir diferentes tipos de vetores devemos usar transformar a matriaz para um objeto do tipo `data.frame` que cria uma estrutura com colunas independentes, permitindo que estas tenham diferentes formatos. Podemos unir os objetos `x` e `z` acima em um data frame como segue:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata.frame(x, z)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n    x z\n1   3 C\n2   4 D\n3   5 E\n4   6 F\n5   7 G\n6   8 H\n7   9 I\n8  10 J\n9  11 K\n10 12 L\n```\n\n\n:::\n:::\n\n\n\nNote que automaticamente, a função atribui nomes as colunas (x e z) e às linhas ($1$ a 10). Estes nomes podem ser alterados com as funções `rownames()` e `colnames()`.\n\nNeste caso, a coluna `x` continua sendo numérica e a coluna `z` continua alfanumérica.\n\nPodemos acessar os elementos de um data frame do mesmo modo que fizemos para matrizes.\n\nPodemos criar um data frame diretamente:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nDados <- data.frame(Regiao = factor(c(\"Santos\", \"Santos\", \n                                     \"Bertioga\", \"Bertioga\", \n                                     \"Peruibe\", \"Peruibe\")),\n                   Especie_A = c(12,43,80,91,75,115), \n                   Especie_B = c(0, 59, 300, 350, 154, 200))\n```\n:::\n\n\n\nE acessá-lo de diferentes formas:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nDados\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n    Regiao Especie_A Especie_B\n1   Santos        12         0\n2   Santos        43        59\n3 Bertioga        80       300\n4 Bertioga        91       350\n5  Peruibe        75       154\n6  Peruibe       115       200\n```\n\n\n:::\n\n```{.r .cell-code}\nDados$Regiao\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] Santos   Santos   Bertioga Bertioga Peruibe  Peruibe \nLevels: Bertioga Peruibe Santos\n```\n\n\n:::\n\n```{.r .cell-code}\nDados[\"Regiao\"]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n    Regiao\n1   Santos\n2   Santos\n3 Bertioga\n4 Bertioga\n5  Peruibe\n6  Peruibe\n```\n\n\n:::\n\n```{.r .cell-code}\nDados[,\"Regiao\"]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] Santos   Santos   Bertioga Bertioga Peruibe  Peruibe \nLevels: Bertioga Peruibe Santos\n```\n\n\n:::\n\n```{.r .cell-code}\nDados[,c(\"Especie_A\",\"Especie_B\")]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  Especie_A Especie_B\n1        12         0\n2        43        59\n3        80       300\n4        91       350\n5        75       154\n6       115       200\n```\n\n\n:::\n:::\n\n\n\n### Listas\n\nCombinam em um único objeto todas as estruturas anteriores. Veja o exemplo em que combinamos um vetor alfanumérico, um vetor nominal e um data frame dentro da mesma lista.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnossalista <- list(Ilha = c(\"Ilhabela\", \"Anchieta\", \"Cardoso\"), \n                  Areaskm2 = c(347.5, 8.3, 131), \n                  Localizacao = data.frame(\n                    Bioma = rep(\"Mata Atlantica\", 3),\n                  Lat = c(23, 25, 23),\n                  Long = c(45, 47, 45)))\nnossalista\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$Ilha\n[1] \"Ilhabela\" \"Anchieta\" \"Cardoso\" \n\n$Areaskm2\n[1] 347.5   8.3 131.0\n\n$Localizacao\n           Bioma Lat Long\n1 Mata Atlantica  23   45\n2 Mata Atlantica  25   47\n3 Mata Atlantica  23   45\n```\n\n\n:::\n:::\n\n\n\nPodemos ainda inserir listas dentro de outras listas, criando estruturas altamente complexas.\n\nPara acessar os elementos de uma lista podemos identificar seu nome após o operador `$` ou sua posição das formas que se seguem:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnossalista$Ilha\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Ilhabela\" \"Anchieta\" \"Cardoso\" \n```\n\n\n:::\n\n```{.r .cell-code}\nnossalista[[1]]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Ilhabela\" \"Anchieta\" \"Cardoso\" \n```\n\n\n:::\n\n```{.r .cell-code}\nnossalista$Localizacao\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n           Bioma Lat Long\n1 Mata Atlantica  23   45\n2 Mata Atlantica  25   47\n3 Mata Atlantica  23   45\n```\n\n\n:::\n\n```{.r .cell-code}\nnossalista[[3]]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n           Bioma Lat Long\n1 Mata Atlantica  23   45\n2 Mata Atlantica  25   47\n3 Mata Atlantica  23   45\n```\n\n\n:::\n:::\n\n\n\n## Operadores relacionais\n\nOperadores relacionais são aqueles de verificam as relações de **menor que** (`<`), **maior que** (`>`), **menor ou igual** (`<=`), **maior ou igual** (`>=`), **igual a** (`==`) ou **diferente de** (`!=`). O resultado de uma comparação retorna um objeto com o argumento **verdadeiro** (`TRUE`) ou **falso** (`FALSE`). Veja por exemplo:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n3 > 5\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n3 > 3\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n3 >= 3\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\na <- 5\nb <- 7\na == b\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\na != b\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n\n\nSe os objetos têm mais de um elemento, no caso de vetores, matrizes ou data frames, a comparação é feita elemento-a-elemento, comparando aqueles que estão na mesma posição, ou seja, os que têm o mesmo *índice de posição*.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\na <- c(3,5,5,7,1)\nb <- c(3,6,1,9,-3)\na < b\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE  TRUE FALSE  TRUE FALSE\n```\n\n\n:::\n:::\n\n\n\nOs operadores `TRUE` e `FALSE`, quanto utilizados em operações aritméticas se comportam respectivamente como valores `1` e `0`.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\na <- 5\nb <- c(3,6,1,9,-3)\ny <- b > a\ny\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE  TRUE FALSE  TRUE FALSE\n```\n\n\n:::\n:::\n\n\n\nSomando os elementos de `y` temos o número de elementos que atendendem à condição acima:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsum(y)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2\n```\n\n\n:::\n:::\n\n\n\nE se tirarmos a média aritmética, teremos a *proporção* de `1`'s no vetor `y`.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmean(y)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.4\n```\n\n\n:::\n:::\n\n\n\n::: callout-note\nLembre-se que ao compararmos vetores de tamanhos distintos, o R **não retorna um erro**, mas recicla os elementos do vetor menor para compensar elementos faltantes.\n:::\n\n## Operadores lógicos\n\nOperadores lógicos são os de **NEGAÇÃO** (`!`), **E lógico**, **OU lógico** versão vetorizada (`|`) e **OU exclusivo** (`xor()`). Exemplos destes operadores são:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 3:5\ny <- 5:3\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n(x < 4)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  TRUE FALSE FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\n!(x < 4)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE  TRUE  TRUE\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n(x < 4) & (y > 4)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  TRUE FALSE FALSE\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n(x < 4) | (y > 4)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  TRUE FALSE FALSE\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nxor(x,y)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE FALSE FALSE\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n:::\n",
    "supporting": [
      "estrutura-linguagem_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}