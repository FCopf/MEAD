{
  "hash": "26222354aaf7ed996de515ea8ba503e8",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Explorando Funções Potências com Python\"\nsubtitulo: \"Implementação do MMQ em funções potência\"\n\nimage: \"images/mmq_regressao_potencia.png\"\nexecute:\n  echo: true\n  warning: false\n  include: true\n  message: false\n\n---\n\n\n## Pacotes e bibliotecas\n\n::: {#fc3cc821 .cell execution_count=1}\n``` {.python .cell-code}\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport pandas as pd\n```\n:::\n\n\n## Definição e Tipos de Funções Potências\n\nUma **função potência** é definida como uma função da forma **$f(x) = x^k$**, em que $k$ é uma constante. \n\nO valor da constante $k$ determina a classificação da função potência:\n\n*   **Monômio: para $k = n$**, onde $n$ é um inteiro positivo. Exemplos - $f(x) = x^2$ ou $f(x) = x^3$.\n*   **Função raiz: para $k = 1/n$**, onde $n$ é um inteiro positivo. Exemplos - $f(x) = x^{1/2}$ (raiz quadrada) ou $f(x) = x^{1/3}$ (raiz cúbica).\n*   **Função recíproca: para $k = -1$**. Ou seja, $f(x) = x^{-1} = 1/x$.\n\n### Definindo e Visualizando Funções Potências em Python\n\nVamos usar o Python para definir e plotar exemplos de cada tipo de função potência. Isso nos ajudará a entender suas características visuais.\n\n::: {#330dff56 .cell execution_count=2}\n``` {.python .cell-code}\n# Definindo a função potência em python\ndef potencia(x, n):\n    \"\"\"Função potência: f(x) = x^k.\"\"\"\n    return x**n\n```\n:::\n\n\nUtilizando a função criada.\n\n::: {#7459fda8 .cell execution_count=3}\n``` {.python .cell-code}\n# Gerando um intervalo de valores para x para plotagem\n# Começamos de 0.1 para evitar divisão por zero na função recíproca.\nx_values = np.linspace(0.1, 5, 400) \n# x_values\n```\n:::\n\n\n::: {#a8bd209e .cell execution_count=4}\n``` {.python .cell-code}\n# Gerando valores de y\ny_values = potencia(x_values, 2)\n# y_values\n```\n:::\n\n\n::: {#52989f18 .cell execution_count=5}\n``` {.python .cell-code}\n# Criando três gráficos lado a lado com diferentes valores de k\n# Criando os subplots\nfig, (ax1, ax2, ax3) = plt.subplots(1, 3, figsize=(8, 3))\n\n# Primeiro gráfico: f(x) = x²\nax1.plot(x_values, potencia(x_values, 2), label='f(x) = x²')\nax1.set_title('Monômio')\nax1.set_xlabel('x')\nax1.set_ylabel('f(x)')\nax1.legend()\nax1.grid(True)\n\n# Segundo gráfico: f(x) = x^(1/2)\nax2.plot(x_values, potencia(x_values, 1/2), label='f(x) = x^(1/2)')\nax2.set_title('Função Raiz')\nax2.set_xlabel('x')\nax2.set_ylabel('f(x)')\nax2.legend()\nax2.grid(True)\n\n# Terceiro gráfico: f(x) = x⁻¹\nax3.plot(x_values, potencia(x_values, -1), label='f(x) = x⁻¹')\nax3.set_title('Função Recíproca')\nax3.set_xlabel('x')\nax3.set_ylabel('f(x)')\nax3.legend()\nax3.grid(True)\n\n# Ajustando o layout e salvando a figura\nplt.tight_layout()\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](funcoes-potencia_files/figure-html/cell-6-output-1.png){width=758 height=278}\n:::\n:::\n\n\n## Exemplo da Relação Espécie-Área\n\nA função potência é amplamente utilizada em ecologia para modelar fenômenos no mundo real. Um exemplo é a relação entre o número de espécies ($S$) e a área de uma região ($A$). A relação entre $S$ e $A$ é geralmente modelada por:\n\n$$S(A) = cA^k$$\n\nEm que $c$ e $k$ são coeficientes que precisam ser determinados a partir de dados observados.\n\nConsidere a tabela de dados que mostra valores de área (A) e riqueza de espécies (S):\n\n| Observação | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |\n|---|---|---|---|---|---|---|---|---|---|\n| A (km²) | 0,25 | 0,5 | 1 | 2 | 4 | 7,9 | 15,9 | 31,6 | 63 |\n| S | 6 | 10 | 13 | 14 | 17 | 19 | 22 | 24 | 28 |\n\nPodemos observar esta relação em Python como segue:\n\n### Definindo a tabela de dados\n\n::: {#8ef50aac .cell execution_count=6}\n``` {.python .cell-code}\n# Dados da tabela\ndata = {\n    'A': [0.25, 0.5, 1, 2, 4, 7.9, 15.9, 31.6, 63],\n    'S': [6, 10, 13, 14, 17, 19, 22, 24, 28]\n}\ndf = pd.DataFrame(data)\n```\n:::\n\n\n### Visualizando o gráfico de dispersão\n\n::: {#0188d528 .cell execution_count=7}\n``` {.python .cell-code}\nplt.figure(figsize=(8, 5))\nplt.scatter(df['A'], df['S'], label='Dados Observados')\nplt.title('Diagrama de Dispersão: Relação Espécie-Área')\nplt.xlabel('Área (km²)')\nplt.ylabel('Número de Espécies')\nplt.grid(True)\nplt.legend()\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](funcoes-potencia_files/figure-html/cell-8-output-1.png){width=660 height=454}\n:::\n:::\n\n\n## Método dos Mínimos Quadrados (MMQ) para o Modelo de Regressão Potência\n\nPodemos utilizar o MMQ para encontrar os coeficientes da relação de potência. Para isso precisamos antes *linearizar a relação*, aplicando o logaritmo em ambos os lados da equação.\n\n::: {.callout-important title=\"Linearizando a relação potência\"}\n\n1.  **Comece com a equação original:**\n    $$S = cA^k$$\n\n2.  **Aplique o logaritmo (de qualquer base) nos dois lados:**\n    $$\\log(S) = \\log(cA^k)$$\n\n3.  **Use a propriedade do logaritmo do produto $\\log(xy) = \\log(x) + \\log(y)$:**\n    $$\\log(S) = \\log(c) + \\log(A^k)$$\n\n4.  **Use a propriedade do logaritmo da potência $\\log(x^p) = p\\log(x)$:**\n    $$\\log(S) = \\log(c) + k\\log(A)$$\n\nAo final, obtemos uma equação linear na forma $y = a + bx$, onde:\n\n* $y = \\log(S)$\n* $x = \\log(A)$\n* O coeficiente angular é $b = k$\n* O intercepto linear (onde a reta cruza o eixo y) é $a = \\log(c)$\n\n:::\n\nApós a linearização, os vetores $\\vec{f}_0$, $\\vec{f}_1$ e $\\vec{y}$, são definidos como segue:\n\n$$\\vec{f}_0 = \\begin{bmatrix} 1 \\\\ 1 \\\\ \\vdots \\\\ 1 \\end{bmatrix} \\quad \\text{,} \\quad \\vec{f}_1 = \\begin{bmatrix} \\log(x_1) \\\\ \\log(x_2) \\\\ \\vdots \\\\ \\log(x_n) \\end{bmatrix} \\quad \\text{e} \\quad \\vec{y} = \\begin{bmatrix} \\log(y_1) \\\\ \\log(y_2) \\\\ \\vdots \\\\ \\log(y_n) \\end{bmatrix}$$\n\nA partir daí, definimos as matrizes $X$ e $Y$ como no modelo linear simples e seguimos com as mesmas operações matriciais.\n\nVamos criar uma função em python que implementa o MMQ:\n\n::: {.callout-important title=\"Função em python para MMQ\"}\n\n::: {#8d142eec .cell execution_count=8}\n``` {.python .cell-code}\ndef mmq(x, y):\n    \"\"\"\n    Calcula os coeficientes (B) e o R² de uma regressão linear simples.\n\n    Args:\n        x (list ou np.ndarray): Os valores da variável independente.\n        y (list ou np.ndarray): Os valores da variável dependente.\n\n    Returns:\n        tuple: Uma tupla contendo a matriz de coeficientes B e o valor de R².\n    \"\"\"\n    # 1. Definição das matrizes do sistema\n    n = len(x)\n    # Converte para array numpy para garantir a funcionalidade\n    x_array = np.array(x)\n    f0 = np.ones(n)\n    f1 = x_array.copy()\n\n    X = np.column_stack((f0, f1))\n    Y = np.array(y).reshape(n, 1)\n\n    # 2. Cálculo dos coeficientes\n    XTX = X.T @ X\n    XTY = X.T @ Y\n    XTX_inv = np.linalg.inv(XTX)\n    B = XTX_inv @ XTY\n    \n    return B\n```\n:::\n\n\n:::\n\nDefinida a função `mmq` basta utilizarmos com um conjunto de dados de entrada.\n\n::: {#63c04c5f .cell execution_count=9}\n``` {.python .cell-code}\n# Ajustando o modelo espécie-área\nB_ea = mmq(np.log(df['A']), np.log(df['S']))\nB_ea\n```\n\n::: {.cell-output .cell-output-display execution_count=24}\n```\narray([[2.4039032 ],\n       [0.24475497]])\n```\n:::\n:::\n\n\n### Visualizando os coeficientes ajustados\n\n::: {#7ad87572 .cell execution_count=10}\n``` {.python .cell-code}\nc = np.exp(B_ea[0])\nk = B_ea[1]\n\nprint('c: ', c)\nprint('k: ', k)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nc:  [11.06628617]\nk:  [0.24475497]\n```\n:::\n:::\n\n\nO modelo de regressão potência para a riqueza de espécies, com base nos dados fornecidos, foi determinado como \n\n$$S(A) = 11.066A^{0.244}$$\n\nOs valores de $c$ e $k$ foram, respectivamente, $11.066$ e $0.244$.\n\n## Visualizando o Ajuste da Curva de Regressão Potência\n\nPodemos criar uma nova função que permitirá encontrar os valores ajustados para o modelo potência a partir dos coeficientes da regressão obtidos.\n\n::: {#f7c5429c .cell execution_count=11}\n``` {.python .cell-code}\ndef S_modelo(novo_x, c, k):\n    y_fit = c * novo_x ** k\n    return y_fit\n```\n:::\n\n\n### Gerando novos valores de x\n\n::: {#0554c7f4 .cell execution_count=12}\n``` {.python .cell-code}\nA_values = np.linspace(np.min(df['A']), np.max(df['A']), 400) \nS_fit = S_modelo(A_values, c, k)\n```\n:::\n\n\n### Plotanto o gráfico\n\n::: {#eb3dbc67 .cell execution_count=13}\n``` {.python .cell-code}\n# Plotar os dados e o modelo ajustado\nplt.figure(figsize=(8, 5))\nplt.scatter(df['A'], df['S'], label='Dados Observados')\nplt.plot(A_values, S_fit, color='red', label=f'Modelo Ajustado: S(A) = {c[0]:.3f}A^{k[0]:.3f}')\nplt.title('Modelo de Regressão Potência Ajustado para Relação Espécie-Área')\nplt.xlabel('Área (km²)')\nplt.ylabel('Número de Espécies')\nplt.grid(True)\nplt.legend()\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](funcoes-potencia_files/figure-html/cell-14-output-1.png){width=660 height=454}\n:::\n:::\n\n\n## Estimativas e Previsões com o Modelo\n\nCom o modelo, podemos estimar a riqueza de espécies para áreas específicas.\n\n::: {#b3a4c5b0 .cell execution_count=14}\n``` {.python .cell-code}\n# Estimando a riqueza de espécies para áreas específicas\nS_10km2 = S_modelo(10, c, k)\nS_70km2 = S_modelo(70, c, k)\n\nprint(f\"Riqueza estimada para uma área de 10 km²: {S_10km2[0]:.3f} ≈ {round(S_10km2[0])} espécies\")\nprint(f\"Riqueza predita para uma área de 70 km²: {S_70km2[0]:.3f} ≈ {round(S_70km2[0])} espécies\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRiqueza estimada para uma área de 10 km²: 19.443 ≈ 19 espécies\nRiqueza predita para uma área de 70 km²: 31.304 ≈ 31 espécies\n```\n:::\n:::\n\n\n### Determinação da Área para Exceder uma Riqueza Específica\n\nO modelo também permite determinar qual área mínima é necessária para que a riqueza de espécies exceda um certo valor. Por exemplo, para exceder 35 espécies, o cálculo é;\n\n$$A > \\left( \\frac{35}{c} \\right)^{1/k}$$\n\n::: {.callout-important title=\"Determinando a área mínima para exceder uma riqueza específica\"}\n\n1.  **Comece com a equação original:**\n    $$S = cA^k$$\n\n2.  **Estabeleça a desigualdade para exceder o valor alvo:**\n    $$cA^k > S_{\\text{alvo}}$$\n\n3.  **Divida ambos os lados por $c$ (como $c > 0$, a desigualdade se mantém):**\n    $$A^k > \\frac{S_{\\text{alvo}}}{c}$$\n\n4.  **Aplique a raiz $k$-ésima em ambos os lados (como $k > 0$, a desigualdade se mantém):**\n    $$A > \\left( \\frac{S_{\\text{alvo}}}{c} \\right)^{1/k}$$\n\n:::\n\n### Resolvendo a Desigualdade\n\n::: {#54a1777a .cell execution_count=15}\n``` {.python .cell-code}\n# Riqueza de espécies alvo\ntarget_species = 35\n\n# Calculando a área necessária\narea_necessaria = (target_species / c)**(1/k)\n\nprint(f\"Para a riqueza exceder {target_species} espécies:\")\nprint(f\"Área deve ser maior que aproximadamente {area_necessaria[0]:.3f} km².\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nPara a riqueza exceder 35 espécies:\nÁrea deve ser maior que aproximadamente 110.441 km².\n```\n:::\n:::\n\n\n",
    "supporting": [
      "funcoes-potencia_files"
    ],
    "filters": [],
    "includes": {}
  }
}