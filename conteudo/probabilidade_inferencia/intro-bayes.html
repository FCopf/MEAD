<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.42">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="description" content="Introdução à inferência bayesiana e contagem de possibilidades">

<title>Introdução à Inferência Bayesiana – Métodos em Estatística e Análise de Dados</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-2f5df379a58b258e96c21c0638c20c03.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-fd75e10d688f5043d524a95775cfac05.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../styles/custom.css">
<meta property="og:title" content="Introdução à Inferência Bayesiana – Métodos em Estatística e Análise de Dados">
<meta property="og:description" content="Introdução à inferência bayesiana e contagem de possibilidades">
<meta property="og:image" content="https://github.com/FCopf/MEAD/conteudo/probabilidade_inferencia/images/intro-bayes.png">
<meta property="og:site_name" content="Métodos em Estatística e Análise de Dados">
<meta property="og:image:height" content="1024">
<meta property="og:image:width" content="1024">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a href="../../index.html" class="navbar-brand navbar-brand-logo">
    <img src="../../images/logo_white.png" alt="" class="navbar-logo">
    </a>
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Métodos em Estatística e Análise de Dados</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="https://github.com/FCopf/MEAD"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text">GitHub</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Nesta página</h2>
   
  <ul>
  <li><a href="#um-leque-de-possibilidades" id="toc-um-leque-de-possibilidades" class="nav-link active" data-scroll-target="#um-leque-de-possibilidades"><span class="header-section-number">1</span> Um leque de possibilidades</a></li>
  <li><a href="#avaliando-as-evidências" id="toc-avaliando-as-evidências" class="nav-link" data-scroll-target="#avaliando-as-evidências"><span class="header-section-number">2</span> Avaliando as evidências</a></li>
  <li><a href="#avaliando-as-demais-hipóteses" id="toc-avaliando-as-demais-hipóteses" class="nav-link" data-scroll-target="#avaliando-as-demais-hipóteses"><span class="header-section-number">3</span> Avaliando as demais hipóteses</a>
  <ul class="collapse">
  <li><a href="#atualizando-o-conhecimento" id="toc-atualizando-o-conhecimento" class="nav-link" data-scroll-target="#atualizando-o-conhecimento"><span class="header-section-number">3.1</span> Atualizando o conhecimento</a></li>
  <li><a href="#de-contagens-a-probabilidades" id="toc-de-contagens-a-probabilidades" class="nav-link" data-scroll-target="#de-contagens-a-probabilidades"><span class="header-section-number">3.2</span> De contagens a probabilidades</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Introdução à Inferência Bayesiana</h1>
<p class="subtitle lead">Texto adaptado do segundo capítulo (<em>Small Worlds and Large Worlds</em>) do livro <em>Statistical Rethinking – A Bayesian Course with Examples in R and Stan</em> <span class="citation" data-cites="mcelreath2018statistical">(<a href="#ref-mcelreath2018statistical" role="doc-biblioref">McElreath 2018</a>)</span> e material disponível em <a href="https://github.com/rmcelreath/rethinking" target="_blank">Statistical Rethinking course and book package</a></p>
</div>

<div>
  <div class="description">
    Introdução à inferência bayesiana e contagem de possibilidades
  </div>
</div>


<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<hr>
<p>A inferência bayesiana, em essência, é uma forma de contar e comparar as diferentes maneiras pelas quais algo pode acontecer. A seguir, vamos desenvolver os princípios da inferência bayesiana de forma simples e intuitiva.</p>
<p>Imagine que temos um saco contendo <strong>quatro</strong> bolinhas de gude, que podem ser <strong>azuis</strong> ou <strong>brancas</strong>. Sabemos que há exatamente quatro bolinhas, mas não conhecemos a distribuição entre as cores. Com base nessa informação, podemos listar cinco configurações possíveis:</p>
<ol type="1">
<li>[⚪⚪⚪⚪]<br>
</li>
<li>[🔵⚪⚪⚪]<br>
</li>
<li>[🔵🔵⚪⚪]<br>
</li>
<li>[🔵🔵🔵⚪]<br>
</li>
<li>[🔵🔵🔵🔵]</li>
</ol>
<p>Essas são todas as possibilidades compatíveis com o que sabemos sobre o conteúdo do saco — o conhecimento <em>a priori</em>. Chamamos essas cinco configurações de <strong>hipóteses</strong>.</p>
<p>Nosso objetivo será descobrir qual dessas hipóteses é mais plausível, à medida que obtivermos evidências sobre o conteúdo do saco.</p>
<section id="um-leque-de-possibilidades" class="level2" data-number="1">
<h2 data-number="1" class="anchored" data-anchor-id="um-leque-de-possibilidades"><span class="header-section-number">1</span> Um leque de possibilidades</h2>
<p>Retiramos uma única bolinha do saco e depois a devolvemos. Antes de dizer qual foi a cor observada, vamos entender como essa observação nos ajuda a alcançar nosso objetivo, avaliando-a à luz de cada uma das hipóteses.</p>
<p>Vamos começar assumindo que seja verdadeira a situação (2) [🔵⚪⚪⚪]. Nesse caso, teríamos 1 possibilidade de observar a bola azul e 3 possibilidades de retirar uma bola branca (<a href="#fig-leque1" class="quarto-xref">Figura&nbsp;1</a>).</p>
<div id="fig-leque1" class="quarto-float quarto-figure quarto-figure-center anchored" style="display: block; margin-left: auto; margin-right: auto;">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-leque1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="images/Diagrama_possibilidades_1.png" class="img-fluid figure-img" style="display: block; margin-left: auto; margin-right: auto;;width:20.0%">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-leque1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figura&nbsp;1: As quatro possibilidades, assumindo que existam três bolinhas brancas e uma azul. Extraído de <span class="citation" data-cites="mcelreath2018statistical">McElreath (<a href="#ref-mcelreath2018statistical" role="doc-biblioref">2018</a>)</span>.
</figcaption>
</figure>
</div>
<div class="callout callout-style-default callout-tip callout-titled" title="Dica útil">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Dica útil
</div>
</div>
<div class="callout-body-container callout-body">
<p>Observe que, embora as três bolinhas brancas pareçam iguais do ponto de vista dos dados (pois apenas registramos suas cores), elas são eventos <strong>diferentes</strong>. Isso é importante, pois significa que há três maneiras a mais de observar ⚪ do que 🔵.</p>
</div>
</div>
<p>Retiramos agora uma <em>segunda</em> bolinha, observamos sua cor e a devolvemos ao saco. Isso expande nosso leque de possibilidades em mais uma camada (<a href="#fig-leque2" class="quarto-xref">Figura&nbsp;2</a>). Agora existem 16 caminhos possíveis (um para cada par de retiradas), pois na segunda retirada, cada um dos caminhos acima se ramifica em outros quatro caminhos possíveis.</p>
<div id="fig-leque2" class="quarto-float quarto-figure quarto-figure-center anchored" style="display: block; margin-left: auto; margin-right: auto;">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-leque2-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="images/Diagrama_possibilidades_2.png" class="img-fluid figure-img" style="display: block; margin-left: auto; margin-right: auto;;width:40.0%">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-leque2-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figura&nbsp;2: Os 16 caminhos possíveis, assumindo que existam três bolinhas brancas e uma azul. Extraído de <span class="citation" data-cites="mcelreath2018statistical">McElreath (<a href="#ref-mcelreath2018statistical" role="doc-biblioref">2018</a>)</span>.
</figcaption>
</figure>
</div>
<p>Ao retirar uma <em>terceira</em> bolinha do saco, a terceira camada é construída da mesma forma, e agora temos <span class="math inline">\(4^3 = 64\)</span> caminhos possíveis para uma sequência de observações de cores em um saco com 4 bolinhas (<a href="#fig-leque3" class="quarto-xref">Figura&nbsp;3</a>).</p>
<div id="fig-leque3" class="quarto-float quarto-figure quarto-figure-center anchored" style="display: block; margin-left: auto; margin-right: auto;">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-leque3-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="images/Fig_2_2.png" class="img-fluid figure-img" style="display: block; margin-left: auto; margin-right: auto;;width:70.0%">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-leque3-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figura&nbsp;3: Os 64 caminhos possíveis, assumindo que existam três bolinhas brancas e uma azul. Extraído de <span class="citation" data-cites="mcelreath2018statistical">McElreath (<a href="#ref-mcelreath2018statistical" role="doc-biblioref">2018</a>)</span>.
</figcaption>
</figure>
</div>
<div class="callout callout-style-default callout-warning callout-titled" title="Importante">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Importante
</div>
</div>
<div class="callout-body-container callout-body">
<p>Acreditamos que, ao sacudir o saco, cada bolinha tem a mesma chance de ser retirada, independentemente de qual tenha saído anteriormente. Por isso, cada caminho do leque é igualmente provável de ser observado.</p>
</div>
</div>
</section>
<section id="avaliando-as-evidências" class="level2" data-number="2">
<h2 data-number="2" class="anchored" data-anchor-id="avaliando-as-evidências"><span class="header-section-number">2</span> Avaliando as evidências</h2>
<p>À medida que retiramos uma nova bolinha do saco e observamos sua cor, alguns desses caminhos são logicamente eliminados.</p>
<p>Suponha que a sequência de cores tenha sido:</p>
<p><strong>1ª bolinha:</strong> 🔵<br>
<strong>2ª bolinha:</strong> ⚪<br>
<strong>3ª bolinha:</strong> 🔵</p>
<p>Após a primeira retirada resultar em 🔵, os três caminhos brancos na parte inferior do leque são imediatamente eliminados. A segunda retirada produziu ⚪, então um dos caminhos possíveis na segunda camada foi eliminado, restando os outros três que se ramificam do primeiro caminho azul. Após a terceira observação, cada um dos três caminhos restantes na segunda camada só segue em direção à bolinha azul na terceira camada. Assim, assumindo que o saco contenha [🔵⚪⚪⚪], existe um total de três maneiras para a sequência [⚪ → ⚪ → 🔵] aparecer. Todas as outras possibilidades foram descartadas à medida que as evidências surgiam.</p>
<p>Dos caminhos restantes na <a href="#fig-2-3" class="quarto-xref">Figura&nbsp;4</a>, não podemos ter certeza de qual desses três caminhos os dados reais seguiram, pois não podemos identificar as bolas individualmente, apenas por sua cor. Entretanto, considerando a hipótese de que o saco contém [🔵⚪⚪⚪], podemos ter certeza de que os dados seguiram um desses três caminhos, pois são os únicos compatíveis tanto com nosso conhecimento prévio (4 bolinhas, azuis ou brancas) quanto com a sequência de dados observada (⚪ → ⚪ → 🔵).</p>
<div id="fig-2-3" class="quarto-float quarto-figure quarto-figure-center anchored" style="display: block; margin-left: auto; margin-right: auto;">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-2-3-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="images/Fig_2_3.png" class="img-fluid figure-img" style="display: block; margin-left: auto; margin-right: auto;;width:70.0%">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-2-3-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figura&nbsp;4: Após eliminar caminhos inconsistentes com a sequência observada, apenas 3 dos 64 caminhos permanecem.
</figcaption>
</figure>
</div>
</section>
<section id="avaliando-as-demais-hipóteses" class="level2" data-number="3">
<h2 data-number="3" class="anchored" data-anchor-id="avaliando-as-demais-hipóteses"><span class="header-section-number">3</span> Avaliando as demais hipóteses</h2>
<p>Considerando que o saco contenha [🔵⚪⚪⚪], verificamos que apenas três dos 64 caminhos possíveis poderiam gerar a sequência [⚪ → ⚪ → 🔵]. Falta agora aplicar a mesma lógica às demais hipóteses. Por exemplo, considere [⚪⚪⚪⚪]. Há zero maneiras de essa hipótese produzir os dados observados, pois um único 🔵 já é logicamente incompatível com ela. A hipótese [🔵🔵🔵🔵] também não pode produzir a sequência, pois há ao menos uma ⚪ observada. Assim, podemos eliminar essas duas hipóteses, pois nenhuma delas fornece sequer um único caminho consistente com os dados.</p>
<p>Para as hipóteses restantes, isto é, [🔵🔵⚪⚪] ou [🔵🔵🔵⚪], o leque de possibilidades se abre novamente.</p>
<p>A <a href="#fig-leque4" class="quarto-xref">Figura&nbsp;5</a> mostra o leque completo para as três hipóteses compatíveis com os dados observados: [🔵⚪⚪⚪], [🔵🔵⚪⚪] e [🔵🔵🔵⚪].</p>
<div id="fig-leque4" class="quarto-float quarto-figure quarto-figure-center anchored" style="display: block; margin-left: auto; margin-right: auto;">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-leque4-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="images/Fig_2_4.png" class="img-fluid figure-img" style="display: block; margin-left: auto; margin-right: auto;;width:70.0%">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-leque4-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figura&nbsp;5: Caminhos de composição possível para cada hipótese logicamente compatível com a sequência observada.
</figcaption>
</figure>
</div>
<p>Agora, contamos todas as maneiras pelas quais cada hipótese poderia produzir os dados observados. Para uma bolinha azul e três brancas, existem três maneiras (como já contamos). Para duas bolinhas azuis e duas brancas, há oito caminhos consistentes com a sequência. Para três bolinhas azuis e uma branca, há nove caminhos que sobrevivem às observações.</p>
<p>Consideramos deste modo, as cinco hipóteses diferentes sobre o conteúdo do saco, variando de zero bolinhas 🔵 a quatro bolinhas 🔵 e, para cada uma dessas hipóteses, contamos quantas possibilidades (ou “caminhos”) poderiam potencialmente produzir a sequência observada.</p>
<div id="tbl-caminhos1" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-tbl figure">
<figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-tbl" id="tbl-caminhos1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Tabela&nbsp;1: <strong>Total de maneiras pelas quais cada hipótese pode gerar a sequência [⚪ → ⚪ → 🔵].</strong>
</figcaption>
<div aria-describedby="tbl-caminhos1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<table class="caption-top table">
<thead>
<tr class="header">
<th><strong>Hipótese</strong></th>
<th><strong>Maneiras de produzir ⚪ → ⚪ → 🔵</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>[⚪⚪⚪⚪]</td>
<td><span class="math inline">\(0 \times 4 \times 0 = 0\)</span></td>
</tr>
<tr class="even">
<td>[🔵⚪⚪⚪]</td>
<td><span class="math inline">\(1 \times 3 \times 1 = 3\)</span></td>
</tr>
<tr class="odd">
<td>[🔵🔵⚪⚪]</td>
<td><span class="math inline">\(2 \times 2 \times 2 = 8\)</span></td>
</tr>
<tr class="even">
<td>[🔵🔵🔵⚪]</td>
<td><span class="math inline">\(3 \times 1 \times 3 = 9\)</span></td>
</tr>
<tr class="odd">
<td>[🔵🔵🔵🔵]</td>
<td><span class="math inline">\(4 \times 0 \times 4 = 0\)</span></td>
</tr>
</tbody>
</table>
</div>
</figure>
</div>
<p>Observe que o número de maneiras de produzir os dados, para cada hipótese, pode ser obtido contando-se as ramificações em cada camada do leque de possibilidades e, em seguida, multiplicando esses valores (<a href="#tbl-caminhos1" class="quarto-xref">Tabela&nbsp;1</a>). Isso é apenas um recurso computacional. Ele nos diz a mesma coisa que a <a href="#fig-leque4" class="quarto-xref">Figura&nbsp;5</a>, mas sem precisar desenhar todo o diagrama. O fato de multiplicarmos os números não altera o sentido de estarmos apenas contando caminhos logicamente possíveis.</p>
<section id="atualizando-o-conhecimento" class="level3" data-number="3.1">
<h3 data-number="3.1" class="anchored" data-anchor-id="atualizando-o-conhecimento"><span class="header-section-number">3.1</span> Atualizando o conhecimento</h3>
<p>Comparando tais contagens, obtemos parte de uma solução para avaliar a plausibilidade relativa de cada hipótese sobre a composição do saco. Mas essa é apenas parte da solução, porque para comparar essas contagens devemos primeiro saber como essas hipóteses poderiam, por si mesmas, ser realizadas. Podemos argumentar que não temos razão para preferir uma hipótese em detrimento de outra e, assim, tratá-las como <em>igualmente plausíveis</em>, comparando as contagens diretamente. Ou podemos ter motivos para fazer diferente.</p>
<p>Às vezes, temos informações adicionais sobre a plausibilidade de cada hipótese. Essas informações podem vir do conhecimento sobre como o conteúdo do saco foi gerado ou de dados anteriores. Seja qual for a fonte, seria útil ter uma forma de combinar diferentes fontes de informação para atualizar as plausibilidades. Felizmente, há uma solução natural para lidar com informações prévias, caso elas existam: simplesmente multiplicamos as contagens.</p>
<p>Para compreender esse processo, suponha que estejamos dispostos a considerar cada hipótese como igualmente plausível. Assim, comparamos as contagens de maneiras pelas quais cada hipótese é compatível com os dados observados. Essa comparação sugere que [🔵🔵🔵⚪] é ligeiramente mais plausível que [🔵🔵⚪⚪] e cerca de três vezes mais plausível que [🔵⚪⚪⚪]. A partir desse momento, estas serão nossas contagens iniciais, que utilizaremos como conhecimento prévio em atualizações futuras. Vamos chamar estas contagens de <strong>priors</strong>.</p>
<p>Agora, suponha que retiramos outra bolinha do saco e observamos a cor: 🔵. Temos duas opções. Podemos começar tudo de novo, desenhando um diagrama com quatro camadas para traçar os caminhos compatíveis com a sequência [⚪ → ⚪ → 🔵 → 🔵]. Ou podemos pegar as contagens anteriores — as <strong>priors</strong> — e apenas atualizá-las de acordo com a nova observação. Esses dois métodos são matematicamente idênticos, desde que a nova evidência seja logicamente independente das observações anteriores.</p>
<p>Assim, fazemos o seguinte: para cada hipótese, listamos as maneiras anteriores de produzir as observações (a <em>prior</em>) e multiplicamos pelo número de maneiras de produzir a nova evidência 🔵:</p>
<div id="tbl-caminhos2" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-tbl figure">
<figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-tbl" id="tbl-caminhos2-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Tabela&nbsp;2: <strong>Total de maneiras pelas quais cada hipótese pode gerar a sequência completa [⚪ → ⚪ → 🔵 → 🔵], combinando a contagem anterior com a nova evidência.</strong>
</figcaption>
<div aria-describedby="tbl-caminhos2-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<table class="caption-top table">
<colgroup>
<col style="width: 17%">
<col style="width: 30%">
<col style="width: 28%">
<col style="width: 23%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;"><strong>Hipótese</strong></th>
<th style="text-align: center;"><strong>Contagem anterior (prior)</strong></th>
<th style="text-align: center;"><strong>Maneiras de produzir 🔵</strong></th>
<th style="text-align: center;"><strong>Nova contagem</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">[⚪⚪⚪⚪]</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;"><span class="math inline">\(0 \times 0 = 0\)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">[🔵⚪⚪⚪]</td>
<td style="text-align: center;">3</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;"><span class="math inline">\(3 \times 1 = 3\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;">[🔵🔵⚪⚪]</td>
<td style="text-align: center;">8</td>
<td style="text-align: center;">2</td>
<td style="text-align: center;"><span class="math inline">\(8 \times 2 = 16\)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">[🔵🔵🔵⚪]</td>
<td style="text-align: center;">9</td>
<td style="text-align: center;">3</td>
<td style="text-align: center;"><span class="math inline">\(9 \times 3 = 27\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;">[🔵🔵🔵🔵]</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">4</td>
<td style="text-align: center;"><span class="math inline">\(0 \times 4 = 0\)</span></td>
</tr>
</tbody>
</table>
</div>
</figure>
</div>
<p>As novas contagens na coluna da direita de <a href="#tbl-caminhos2" class="quarto-xref">Tabela&nbsp;2</a> resumem todas as evidências para cada hipótese antes de uma nova observação. À medida que novos dados chegam e desde que sejam independentes dos anteriores, o total de caminhos logicamente possíveis para explicar tanto as observações antigas quanto as novas pode ser calculado pela multiplicação das contagens atuais pelas anteriores.</p>
<p>Em outras palavras, sempre que contamos <span class="math inline">\(W_\text{prior}\)</span> maneiras de uma hipótese produzir observações anteriores <span class="math inline">\(D_\text{prior}\)</span> e, em seguida, obtemos novas observações <span class="math inline">\(D_\text{novo}\)</span> que a mesma hipótese pode produzir de <span class="math inline">\(W_\text{novo}\)</span> maneiras, a quantidade total de formas possíveis para essa hipótese explicar <strong>todas</strong> as observações é simplesmente <span class="math inline">\(W_\text{prior} \times W_\text{novo}\)</span>. Por exemplo, na <a href="#tbl-caminhos2" class="quarto-xref">Tabela&nbsp;2</a>, a hipótese [🔵🔵⚪⚪] apresenta <span class="math inline">\(W_\text{prior} = 8\)</span> maneiras de gerar as observações anteriores [⚪⚪🔵] e <span class="math inline">\(W_\text{novo} = 2\)</span> maneiras de gerar a nova observação [🔵]. Logo, <span class="math inline">\(8 \times 2 = 16\)</span> caminhos possíveis para explicar tanto os dados antigos quanto os novos.</p>
<div class="callout callout-style-default callout-warning callout-titled" title="Importante">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Importante
</div>
</div>
<div class="callout-body-container callout-body">
<p>No exemplo acima, os dados antigos e os novos são do mesmo tipo (bolinhas retiradas do saco). Entretanto, não há motivo para excluir a situação em que os dados antigos e os novos tenham sido obtidos de forma diferente. Suponha, por exemplo, que alguém da fábrica de bolinhas informe que as azuis são raras. Para cada saco contendo [🔵🔵🔵⚪], a fábrica produz dois sacos contendo [🔵🔵⚪⚪] e três sacos contendo [🔵⚪⚪⚪]. Também garante que cada saco contenha pelo menos uma bolinha azul e uma bolinha branca. Com essa nova informação, podemos atualizar nossas contagens novamente <a href="#tbl-caminhos3" class="quarto-xref">Tabela&nbsp;3</a>.</p>
<div id="tbl-caminhos3" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-tbl figure">
<figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-tbl" id="tbl-caminhos3-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Tabela&nbsp;3: <strong>Contagens atualizadas após incorporar a nova observação 🔵 e as informações externas sobre a frequência das hipóteses.</strong>
</figcaption>
<div aria-describedby="tbl-caminhos3-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<table class="caption-top table">
<colgroup>
<col style="width: 18%">
<col style="width: 31%">
<col style="width: 29%">
<col style="width: 20%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;"><strong>Hipótese</strong></th>
<th style="text-align: center;"><strong>Contagem anterior (prior)</strong></th>
<th style="text-align: center;"><strong>Maneiras de produzir 🔵</strong></th>
<th style="text-align: center;"><strong>Nova contagem</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">[⚪⚪⚪⚪]</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;"><span class="math inline">\(0 \times 0 = 0\)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">[🔵⚪⚪⚪]</td>
<td style="text-align: center;">3</td>
<td style="text-align: center;">3</td>
<td style="text-align: center;"><span class="math inline">\(3 \times 3 = 9\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;">[🔵🔵⚪⚪]</td>
<td style="text-align: center;">16</td>
<td style="text-align: center;">2</td>
<td style="text-align: center;"><span class="math inline">\(16 \times 2 = 32\)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">[🔵🔵🔵⚪]</td>
<td style="text-align: center;">27</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;"><span class="math inline">\(27 \times 1 = 27\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;">[🔵🔵🔵🔵]</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;"><span class="math inline">\(0 \times 0 = 0\)</span></td>
</tr>
</tbody>
</table>
</div>
</figure>
</div>
<p>Agora, à luz dessa informação inicial, a hipótese [🔵🔵⚪⚪] torna-se ligeiramente mais plausível do que [🔵🔵🔵⚪].</p>
</div>
</div>
</section>
<section id="de-contagens-a-probabilidades" class="level3" data-number="3.2">
<h3 data-number="3.2" class="anchored" data-anchor-id="de-contagens-a-probabilidades"><span class="header-section-number">3.2</span> De contagens a probabilidades</h3>
<p>Quase sempre é impraticável usar essas contagens em situações reais. Por isso, costumamos padronizá-las em <strong>probabilidades</strong>. Isso faz sentido porque apenas os valores relativos importam. Em termos relativos, as proporções entre as contagens 3, 8 e 9 são as mesmas que em 30, 80 e 90. Além disso, à medida que a quantidade de dados cresce, as contagens tornam-se muito grandes e difíceis de manipular. Por fim, se estivermos lidando com variáveis contínuas, não é sequer possível “contar” caminhos, e precisamos pensar em <em>espaços de possibilidades</em>.</p>
<p>Felizmente, existe uma forma matemática de comprimir tudo isso. Definimos a plausibilidade atualizada de cada composição possível, depois de observar os dados, como sendo:</p>
<p><span class="math display">\[\text{plausibilidade de [🔵⚪⚪⚪] após observar ⚪⚪🔵} \;\;\]</span> <span class="math display">\[\propto \;\;\]</span> <span class="math display">\[\text{(maneiras que [🔵⚪⚪⚪] pode produzir ⚪⚪🔵)} \;\]</span> <span class="math display">\[\times\;\]</span> <span class="math display">\[\text{(plausibilidade anterior de [🔵⚪⚪⚪])}.\]</span></p>
<p>O símbolo <span class="math inline">\(\propto\)</span> significa “proporcional a”.</p>
<p>Retomando a <a href="#tbl-caminhos2" class="quarto-xref">Tabela&nbsp;2</a>, em vez de descrever o conhecimento <em>a priori</em> por contagens absolutas, podemos descrevê-lo por frequências relativas, de modo que elas somem 1. Ao fazer isso, o resultado das multiplicações será diferente em valores absolutos, mas manterá a mesma relação de plausibilidade entre as hipóteses. Por fim, podemos normalizar esses valores, obtendo a probabilidade de cada hipótese à luz das novas informações, como na <a href="#tbl-caminhos4" class="quarto-xref">Tabela&nbsp;4</a>.</p>
<div id="tbl-caminhos4" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-tbl figure">
<figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-tbl" id="tbl-caminhos4-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Tabela&nbsp;4: <strong>Atualização das plausibilidades relativas com base em uma nova evidência, seguida de normalização para obtenção das probabilidades associadas a cada hipótese.</strong>
</figcaption>
<div aria-describedby="tbl-caminhos4-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<table class="caption-top table">
<colgroup>
<col style="width: 16%">
<col style="width: 10%">
<col style="width: 25%">
<col style="width: 18%">
<col style="width: 29%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;"><strong>Hipótese</strong></th>
<th style="text-align: center;"><strong>Prior</strong></th>
<th style="text-align: center;"><strong>Maneiras de produzir 🔵</strong></th>
<th style="text-align: center;"><strong>Plausibilidade</strong></th>
<th style="text-align: center;"><strong>Plausibilidade normalizada</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">[⚪⚪⚪⚪]</td>
<td style="text-align: center;">0.00</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;"><span class="math inline">\(0.00 \times 0 = 0.00\)</span></td>
<td style="text-align: center;">0.000</td>
</tr>
<tr class="even">
<td style="text-align: left;">[🔵⚪⚪⚪]</td>
<td style="text-align: center;">0.15</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;"><span class="math inline">\(0.15 \times 1 = 0.15\)</span></td>
<td style="text-align: center;">0.065</td>
</tr>
<tr class="odd">
<td style="text-align: left;">[🔵🔵⚪⚪]</td>
<td style="text-align: center;">0.40</td>
<td style="text-align: center;">2</td>
<td style="text-align: center;"><span class="math inline">\(0.40 \times 2 = 0.80\)</span></td>
<td style="text-align: center;">0.348</td>
</tr>
<tr class="even">
<td style="text-align: left;">[🔵🔵🔵⚪]</td>
<td style="text-align: center;">0.45</td>
<td style="text-align: center;">3</td>
<td style="text-align: center;"><span class="math inline">\(0.45 \times 3 = 1.35\)</span></td>
<td style="text-align: center;">0.587</td>
</tr>
<tr class="odd">
<td style="text-align: left;">[🔵🔵🔵🔵]</td>
<td style="text-align: center;">0.00</td>
<td style="text-align: center;">4</td>
<td style="text-align: center;"><span class="math inline">\(0.00 \times 4 = 0.00\)</span></td>
<td style="text-align: center;">0.000</td>
</tr>
</tbody>
</table>
</div>
</figure>
</div>
<p>O resultado final da inferência é a atribuição de <strong>probabilidades</strong> — números não negativos, que somam 1 — a cada uma das hipóteses concorrentes.</p>



</section>
</section>

<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents" role="doc-bibliography" id="quarto-bibliography"><h2 class="anchored quarto-appendix-heading">References</h2><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list">
<div id="ref-mcelreath2018statistical" class="csl-entry" role="listitem">
McElreath, Richard. 2018. <em>Statistical Rethinking: A Bayesian Course with Examples in r and Stan</em>. Chapman; Hall/CRC.
</div>
</div></section></div></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/github\.com\/FCopf\/MEAD");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>